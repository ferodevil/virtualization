# 无线网卡桥接总结

## 背景介绍

* 无线场景下，虚拟机中通过nat方式与外界互联；有线场景下，虚拟机通过bridge方式与外界互联；

* 无线网卡处于managed模式；

## 问题介绍

直接将wlan0加入到虚拟网桥提示Operation not supported：

```
root:~# brctl show
bridge name  bridge id          STP enabled interfaces
br0          8000.58696cff3bba  no          eth0
                                            vnet0
root:~# brctl addif br0 wlan0
can't add wlan0 to bridge br0: Operation not supported
```

## 原因分析

* **kernel限制**

直接原因为kernel网桥模块对此进行了限制，通过查看内核源码可知：

```
...
if ((wdev->iftype == NL80211_IFTYPE_STATION ||
    wdev->iftype == NL80211_IFTYPE_ADHOC) && !wdev->use_4addr)
      dev->priv_flags |= IFF_DONT_BRIDGE;
...
/* No bridging devices that dislike that (e.g. wireless) */
if (dev->priv_flags & IFF_DONT_BRIDGE)
    return -EOPNOTSUPP;
```

802.11协议为点对点协议，所有数据包都需要ack且必须要发送到特定正确的地址，为了避免不必要的问题，内核在2.6版本后限制将managed模式的无线网卡加入到虚拟网桥；

或者反过来假设将wlan0成功加入虚拟网桥br0，此时需要两套ip/mac地址，wlan0需要一套，虚拟机也同样需要一套，这样也与802.11协议相背。

[https://github.com/torvalds/linux/commit/ad4bb6f8883a13bb0f65b194dae36c62a02ac779](https://github.com/torvalds/linux/commit/ad4bb6f8883a13bb0f65b194dae36c62a02ac779)

* **尝试**

如上，当使用4addr模式时候，kernel网桥不会限制此无线网卡桥接，分析是否能通过4addr来解决此问题；同时结合网上找的一些相关资料，要想把无线网卡加入网桥，基本上都是将无线网卡直接设置（通过hostapd）成master模式，或者通过iw将无线网卡设置为4addr模式。

```
iw dev <devname> set 4addr <on|off>
    Set interface 4addr (WDS) mode.
```

尝试结果如下：

> aster模式将终端变成ap，而我们的最终目的为连ap上网，不符合要求；
>
> 4addr模式即WDS模式，目的为级联ap，也不符合要求；

## 附录

### 802.11 mac帧格式

![](https://github.com/ferodevil/virtualization/blob/master/assets/802.11%E5%B8%A7%E6%A0%BC%E5%BC%8F.png)

根据802.11 MAC帧的传输方式，可以将MAC帧的地址结构分为三地址结构和四地址结构。其中，AP与STA之间传输的MAC帧采用三地址结构，AP与AP之间传输的MAC帧采用四地址结构;

![](https://github.com/ferodevil/virtualization/blob/master/assets/%E7%A4%BA%E4%BE%8B1.png)

如图所示，如果STA 1与STA 2通信，STA 1发送三地址结构的MAC帧给AP 2，三个地址字段依次填充AP2、STA 1、STA 2的MAC地址信息（参见表STA 1 -&gt; AP 2），AP 2收到后转发给STA 2，三个地址字段依次修改为STA 2、AP 2、STA 1的MAC地址信息（参见表AP 2 -&gt; STA 2）；如果STA 1与STA 3通信，AP 2收到STA 1的MAC帧后需要转发给AP 1，便将三地址结构修改为四地址结构，四个地址字段依次填充为AP 2、AP 1、STA 3、STA 1的MAC地址信息（参见表AP 2 -&gt; AP 1），AP 1收到后转发给STA 3，又将四地址结构修改为三地址结构。

> ```
> 传输方式         Address 1   Address 2   Address 3   Address 4
> STA 1 -> AP2    RA = AP 2   TA = STA 1  DA = STA 2  N/A
> AP 2 -> STA 2   RA = STA 2  TA = AP 2   SA = STA 1  N/A
> AP 2 -> AP 1    RA = AP 1   TA = AP 2   DA = STA 3  SA = STA 1
> ```

### Bridge wlan and 4addr

Bridging wlan0 is a pain. You normally cannot add it to a bridge interface \(brctl returns "Operation not permitted"\), and using VirtualBox "bridged" filter results in a big mess of ARP and DHCP conflicts. The cause of this is that 802.11 frames contain only three addresses by default: the MAC addresses of both wireless devices \(laptop and AP\) and of the final recipient \(as in Ethernet\). It is always assumed that there is only one possible originator.

802.11 can carry the fourth, originator's MAC address, and this is used in WDS mode by repeaters. This feature can be enabled on Linux too, using iw, and enabling this mode will allow wlan0 to be used in bridge interfaces, as well as with VirtualBox bridged networking:

```
iw dev wlan0 set 4addr on
```

However, with 4addr enabled, you're likely to get completely ignored by the AP: association succeeds but all data frames disappear into the ether. This could be for security reasons \(because it's damn hard to spoof the source MAC address. Yeah.\) In my router \(running OpenRG\), it's necessary to enable "WDS" mode for the wireless AP interface, add a WDS device restricted to my laptop's MAC address, and add it to the LAN bridge. 4addr packets now work.

Some people have asked why use this when VirtualBox can bridge WiFi "just fine". The answer is that VirtualBox does not send the virtual machines' MAC addresses; rather, it performs NAT at the MAC layer too.

* **Masquerade alternative**

Linux routing can be used instead with iptables-masquerade and ip \_forward to achieve a bridge but as mentioned this require to enable ip\_forward and will make linux act like a router this need to be setup carefully because it could introduce some security concern.

```
# bridge setup
brctl addbr br0
ifconfig br0 10.10.20.1/24 up

# enable ipv4 forwarding
echo "1" > /proc/sys/net/ipv4/ip_forward

# netfilter cleanup
iptables --flush
iptables -t nat -F
iptables -X
iptables -Z
iptables -P INPUT ACCEPT
iptables -P OUTPUT ACCEPT
iptables -P FORWARD ACCEPT

# netfilter network address translation
iptables -t nat -A POSTROUTING -o wlan0 -s 10.10.20.0/24  -j MASQUERADE
```

* **Direct wlan bridge**

Under certain circumstances, you could also use wlankabel. It uses packet sockets to directly bridge wlan\*-devices with ethernet devices. However, you can only bridge one single MAC at a time with wlankabel. It doesn't have the drawback of being barred by access points, because only the original MAC of the wlan device is used. In your case this would mean, that wlan0 could only be used by one VM and not even by the host. You can get wlan\_kabel here. This is similar to the macvlans solution.

[https://github.com/escitalopram/wlan\_kabel](https://github.com/escitalopram/wlan_kabel "how to get wlan\_kabel")

[https://superuser.com/questions/1113812/how-to-configure-macvlan-interface-for-getting-the-ip/1114044\#1114044](https://superuser.com/questions/1113812/how-to-configure-macvlan-interface-for-getting-the-ip/1114044#1114044)

* **Bridging with ipvlan**

IP Vlan does not have the limitation of a bridge it could be used to bridge a network details on how to use it can be found here.

[https://unix.stackexchange.com/questions/391295/how-can-you-assign-one-ip-per-user/391297\#391297](https://unix.stackexchange.com/questions/391295/how-can-you-assign-one-ip-per-user/391297#391297)

* [x] **Important and related**

Also, and very important, you should not use obsolete, deprecated commands like ifconfig, brctl, and so on. The iproute2 suite contains commands for all of this, including setting up virtual interfaces \(something for which we once had to use openvpn\) and creating bridges. If you do not know how to set up a bridge with ip, here we go.

```
ip tuntap add tap0 mode tap user root
ip link set tap0 up
ip link add br0 type bridge
ip link set tap0 master br0
ip link set eth0 master br0
ip addr add 10.173.10.1/24  dev br0
ip link set br0 up
```

With this set of commands, we create a virtual interface called tap0, then a bridge called br0, then enslave eth0 and tap0 to the bridge, to which we assign an IP address of 10.173.10.1, then bring it all up. The three separate instances of bringing the interfaces up \(for tap0, eth0, and br0\) are required.

The trick to make this work is to use proxy.arp, which allows your pc \(not your VM/Linux container/network namespace\) to answer ARP queries in their stead.

In other words, by using IPv4 forwarding between your hardware interface and your virtual interface, you think you can connect your VM/LXC/NNS to your LAN as if it were a physical interface, but this is not true: you are forgetting the absolutely fundamental ARP traffic, which is what truly allows LAN to operate. So, the problem is: if I correctly forward IPv4 traffic, how can I also forward ARP traffic, so that my VM/LXC/NNS work? The trick is to use proxy-arp.

The full answer to that is in Bohdi Zazen's Blog, with the revealing title: Bridge wireless cards. He uses an obsolete package, uml-utilities, to create a virtual interface by means of the command tunctl: this is the only command for which he uses uml-utilities, so that you can safely neglect downloading the package, and use the command I wrote above to create a tap or tun interface, whichever you like, just modify the command accordingly. then create a veth pair for your LXC, and now create a bridge between tap0 and veth0. This bridge, called br0, is what you must proxy-arp for, instead of the simple tap0 interface described by Bohdi Zazen.

[https://serverfault.com/questions/152363/bridging-wlan0-to-eth0](https://serverfault.com/questions/152363/bridging-wlan0-to-eth0)

